export adjtdvp1vec!

using ITensors: position!

"""
    adjtdvp1vec!(operator::MPS, initialstate::MPS, H::MPO, Δt, tf, meas_stride, sites; kwargs...)

Compute the time evolution, generated by the GKSL superoperator encoded in `H`, of the
operator `operator` in the Heisenberg picture, periodically measuring its expectation
value on the state `initialstate`.

# Arguments
- `operator::MPS`: an MPS representing the initial value of the operator.
- `initialstate::MPS` an MPS representing the initial state of the system.
- `H::MPO`: the MPO representing the GKSL "superoperator".
- `Δt`: the time step for the evolution.
- `tf`: the end time of the simulation.
- `meas_stride`: time between each measurement.
- `sites`: an array of ITensor sites on which the MPSs and MPOs above are defined.

# Keyword arguments
- `io_file`: output file of the measurements.
- `ranks_file`: output file for the bond dimensions of the operator's MPS.
- `times_file`: output file for the simulation time.

# Other keyword options, passed to `KrylovKit.exponentiate`
- `exp_tol::Real` -> `tol`
- `krylovdim::Int`
- `maxiter::Int`
"""
function adjtdvp1vec!(
    operator::MPS, initialstate::MPS, H::MPO, Δt, tf, meas_stride, sites; kwargs...
)
    nsteps = Int(tf / Δt)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving operator... ")
    else
        pbar = nothing
    end

    # Vectorized equations of motion usually are not defined by an anti-Hermitian operator
    # such as -im H in Schrödinger's equation, so we do not bother here with "unitary" or
    # "imaginary-time" evolution types. We just have a generic equation of the form
    # v'(t) = L v(t).

    io_handle = open(io_file, "w")
    @printf(io_handle, "%20s", "time")
    @printf(io_handle, "%20s", "exp_val")
    @printf(io_handle, "\n")

    ranks_handle = writeheaders_ranks(ranks_file, length(operator))
    times_handle = writeheaders_stime(times_file)

    N = length(operator)

    # Prepare for first iteration.
    orthogonalize!(operator, 1)
    PH = ProjMPO(H)
    singlesite!(PH)
    position!(PH, operator, 1)

    prev_t = zero(Δt)
    for s in 1:nsteps
        stime = @elapsed begin
            # In TDVP1 only one site at a time is modified, so we iterate on the sites
            # of the operator MPS, not its bonds.
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.
                sweepdir = (ha == 1 ? "right" : "left")
                tdvp_site_update!(
                    PH,
                    operator,
                    site,
                    0.5Δt;
                    sweepdir=sweepdir,
                    hermitian=false,
                    exp_tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                )
            end
        end
        prev_t += Δt
        t = Δt * s

        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", t),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(operator)),
            ],
        )

        # Now the backwards sweep has ended, so the whole MPS of the operator is up-to-date.
        # We can then calculate the expectation values on the initial state.
        #if t - prev_t ≈ meas_stride... how does this work?
        if true # FIXME
            @printf(io_handle, "%40.15f", t)
            @printf(io_handle, "%40.15f", real(inner(initialstate, operator)))
            @printf(io_handle, "\n")
            flush(io_handle)

            @printf(ranks_handle, "%40.15f", t)
            for bonddim in ITensors.linkdims(operator)
                @printf(ranks_handle, "%10d", bonddim)
            end
            @printf(ranks_handle, "\n")
            flush(ranks_handle)

            printoutput_stime(times_handle, stime)
        end
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end
