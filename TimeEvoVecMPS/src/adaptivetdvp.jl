export adaptbonddimensions!, adaptivetdvp1!, adaptivetdvp1vec!, adaptiveadjtdvp1vec!

"""
    bondconvergencemeasure(PH::AbstractProjMPO, state::MPS, bond::Integer)

Return a measure of the convergence for the bond dimension on the bond (`bond`, `bond+1`)
of the MPS `state` for a time-evolution determined by `PH`. See [1] for details.

# References:
[1] Dunnett, Angus J. and Chin, Alex W. (2020).
“Dynamically Evolving Bond-Dimensions within the one-site
Time-Dependent-Variational-Principle method for Matrix Product States: Towards efficient
simulation of non-equilibrium open quantum dynamics”
https://doi.org/10.48550/arXiv.2007.13528
"""
function bondconvergencemeasure(PH::ITensors.AbstractProjMPO, v::MPS, bond::Integer)::Real
    #orthogonalize!(v, bond) # this causes trouble

    ITensors.set_nsite!(PH, 1)
    ITensors.position!(PH, v, bond)
    H1 = PH(v[bond])

    Q, R = factorize(
        v[bond], uniqueinds(v[bond], v[bond + 1]); ortho="left", which_decomp="qr"
    )
    vv = copy(v)
    vv[bond] = Q
    vv[bond + 1] *= R
    ITensors.setleftlim!(vv, bond)
    ITensors.setrightlim!(vv, bond + 1)

    ITensors.position!(PH, vv, bond + 1)
    H2 = PH(vv[bond + 1])

    ITensors.set_nsite!(PH, 0)
    ITensors.position!(PH, vv, bond + 1) # Force recalculation
    K = PH(R)

    return norm(H1)^2 + norm(H2)^2 + norm(K)^2
end

"""
    function adaptbonddimensions!(
        v::MPS, PH::AbstractProjMPO, max_bond::Int, convergence_factor_bonddims::Real
    )

If necessary, enlarge the bond dimensions of the MPS `v`, so that it can dynamically and
inhomogeneously restructure itself as the complexity of the correlations grow during the
time evolution generated by `H` [1].

# References:
[1] Dunnett, Angus J. and Chin, Alex W. (2020).
“Dynamically Evolving Bond-Dimensions within the one-site
Time-Dependent-Variational-Principle method for Matrix Product States: Towards efficient
simulation of non-equilibrium open quantum dynamics”
https://doi.org/10.48550/arXiv.2007.13528
"""
function adaptbonddimensions!(
    v::MPS, PH::ITensors.AbstractProjMPO, max_bond::Int, convergence_factor_bonddims::Real
)
    maxbonddimensions = maxlinkdims(v, max_bond)
    for bond in 1:(length(v) - 1)
        if linkdim(v, bond) < maxbonddimensions[bond]
            # Skip all this if the bond is already at (or above!) the maximum
            # allowed value.
            f = bondconvergencemeasure(PH, v, bond)
            while true # (do-while block emulation)
                # Increase the bond dimension by 1, check convergence, repeat if needed.
                vcopy = copy(v)
                new_bonddim = growbond!(vcopy, bond)
                # Update PH using the new sites at `bond` and `bond + 1`:
                recompute!(PH, vcopy, bond)
                new_f = bondconvergencemeasure(PH, vcopy, bond)

                # If new_f / f ≈ 1, within the given threshold, then f was already OK
                # and we discard the new MPS, keeping the non-enlarged state.
                if (new_f / f - 1 > convergence_factor_bonddims && new_bonddim ≤ max_bond)
                    d = growbond!(v, bond) # Actually increase v's bond dimensions
                    #d = linkdim(v, bond)
                    @debug "[Bond ($bond,$(bond+1))] f($d)/f($(d-1)) - 1 > " *
                        "$convergence_factor_bonddims: increasing dimension to $d."
                    f = new_f # and begin a new iteration of the while block.
                else
                    # Bring PH back to its form before v's bond dimension was increased.
                    recompute!(PH, v, bond)
                    @debug "[Bond ($bond,$(bond+1))] Convergence reached at d=$(linkdim(v, bond))."
                    break # and proceed with the next bond in the MPS.
                end
            end
        else
            @debug "[Bond ($bond,$(bond+1))] Max dimension reached. Skipping."
        end
    end
    return nothing
end

"""
    adaptivetdvp1!(solver, state::MPS, H::Vector{MPO}, Δt::Number, tf::Number; kwargs...)

Like `tdvp1!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`tdvp1!`](@ref).
"""
function adaptivetdvp1!(
    solver, psi0::MPS, Hs::Vector{MPO}, time_step::Number, tf::Number; kwargs...
)
    # (Copied from ITensorsTDVP)
    for H in Hs
        ITensors.check_hascommoninds(siteinds, H, psi0)
        ITensors.check_hascommoninds(siteinds, H, psi0')
    end
    Hs .= ITensors.permute.(Hs, Ref((linkind, siteinds, linkind)))
    PHs = ProjMPOSum(Hs)
    return adaptivetdvp1!(solver, psi0, PHs, time_step, tf; kwargs...)
end

"""
    adaptivetdvp1!(solver, state::MPS, H::MPO, Δt::Number, tf::Number; kwargs...)

Like `tdvp1!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`tdvp1!`](@ref).
"""
function adaptivetdvp1!(solver, state::MPS, H::MPO, timestep::Number, tf::Number; kwargs...)
    return adaptivetdvp1!(solver, state::MPS, ProjMPO(H), timestep, tf; kwargs...)
end

"""
    adaptivetdvp1!(solver, state::MPS, PH, Δt::Number, tf::Number; kwargs...)

Like `tdvp1!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`tdvp1!`](@ref).
"""
function adaptivetdvp1!(solver, state::MPS, PH, timestep::Number, tf::Number; kwargs...)
    nsteps = Int(tf / timestep)
    cb = get(kwargs, :callback, NoTEvoCallback())
    hermitian = get(kwargs, :hermitian, true)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    normalize = get(kwargs, :normalize, true)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)
    store_state0 = get(kwargs, :store_psi0, false)
    convergence_factor_bonddims = get(kwargs, :convergence_factor_bonddims, 1e-4)
    max_bond = get(kwargs, :max_bond, maxlinkdim(state))

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving state... ")
    else
        pbar = nothing
    end

    Δt = im * timestep
    imag(Δt) == 0 && (Δt = real(Δt))

    store_state0 && (state0 = copy(state))

    io_handle = writeheaders_data(io_file, cb; kwargs...)
    ranks_handle = writeheaders_ranks(ranks_file, length(state))
    times_handle = writeheaders_stime(times_file)

    N = length(state)

    # Prepare for first iteration
    orthogonalize!(state, 1)
    singlesite!(PH)
    position!(PH, state, 1)

    current_time = 0.0
    for s in 1:nsteps
        orthogonalize!(state, 1)
        ITensors.set_nsite!(PH, 1)
        position!(PH, state, 1)

        # Before each sweep, we grow the bond dimensions a bit.
        # See Dunnett and Chin, 2020 [arXiv:2007.13528v2].
        @debug "[Step $s] Attempting to grow the bond dimensions."
        adaptbonddimensions!(state, PH, max_bond, convergence_factor_bonddims)

        stime = @elapsed begin
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.
                sweepdir = (ha == 1 ? "right" : "left")
                tdvp_site_update!(
                    solver,
                    PH,
                    state,
                    site,
                    -0.5Δt;
                    current_time=(ha == 1 ? current_time + 0.5timestep : current_time + timestep),
                    sweepdir=sweepdir,
                    hermitian=hermitian,
                    exp_tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                )
                apply!(
                    cb,
                    state;
                    t=current_time,
                    bond=site,
                    sweepend=(ha == 2),
                    sweepdir=sweepdir,
                    alg=TDVP1(),
                )
            end
        end
        current_time += timestep

        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", current_time),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(state)),
            ],
        )

        if !isempty(measurement_ts(cb)) && current_time ≈ measurement_ts(cb)[end]
            if store_state0
                printoutput_data(io_handle, cb, state; psi0=state0, kwargs...)
            else
                printoutput_data(io_handle, cb, state; kwargs...)
            end
            printoutput_ranks(ranks_handle, cb, state)
            printoutput_stime(times_handle, stime)
        end

        checkdone!(cb) && break
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end

"""
    adaptivetdvp1vec!(solver, state::MPS, H::MPO, Δt::Number, tf::Number, sites; kwargs...)

Like `tdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`tdvp1vec!`](@ref).
"""
function adaptivetdvp1vec!(
    solver, psi0::MPS, Ls::Vector{MPO}, time_step::Number, tf::Number, sites; kwargs...
)
    # (Copied from ITensorsTDVP)
    for H in Hs
        ITensors.check_hascommoninds(siteinds, H, psi0)
        ITensors.check_hascommoninds(siteinds, H, psi0')
    end
    Hs .= ITensors.permute.(Hs, Ref((linkind, siteinds, linkind)))
    PHs = ProjMPOSum(Hs)
    return tdvp1vec!(solver, psi0, PHs, time_step, tf, sites; kwargs...)
end

"""
    adaptivetdvp1vec!(solver, state::MPS, L::MPO, Δt::Number, tf::Number, sites; kwargs...)

Like `tdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`tdvp1vec!`](@ref).
"""
function adaptivetdvp1vec!(solver, state::MPS, L::MPO, Δt::Number, tf::Number, sites; kwargs...)
    return adaptivetdvp1vec!(solver, state, ProjMPO(L), Δt, tf, sites; kwargs...)
end

"""
    adaptivetdvp1vec!(solver, state::MPS, L, Δt::Number, tf::Number, sites; kwargs...)

Like `tdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`tdvp1vec!`](@ref).
"""
function adaptivetdvp1vec!(solver, state::MPS, PH, Δt::Number, tf::Number, sites; kwargs...)
    nsteps = Int(tf / Δt)
    cb = get(kwargs, :callback, NoTEvoCallback())
    hermitian = get(kwargs, :hermitian, true)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    normalize = get(kwargs, :normalize, false)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)
    store_state0 = get(kwargs, :store_psi0, false)
    convergence_factor_bonddims = get(kwargs, :convergence_factor_bonddims, 1e-4)
    max_bond = get(kwargs, :max_bond, maxlinkdim(state))

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving state... ")
    else
        pbar = nothing
    end

    # Vectorized equations of motion usually are not defined by an anti-Hermitian operator
    # such as -im H in Schrödinger's equation, so we do not bother here with "unitary" or
    # "imaginary-time" evolution types. We just have a generic equation of the form
    # v'(t) = L v(t).

    store_state0 && (state0 = copy(state))

    io_handle = writeheaders_data(io_file, cb; kwargs...)
    ranks_handle = writeheaders_ranks(ranks_file, length(state))
    times_handle = writeheaders_stime(times_file)

    N = length(state)

    current_time = 0.0
    for s in 1:nsteps
        orthogonalize!(state, 1)
        ITensors.set_nsite!(PH, 1)
        position!(PH, state, 1)

        # Before each sweep, we grow the bond dimensions a bit.
        # See Dunnett and Chin, 2020 [arXiv:2007.13528v2].
        @debug "[Step $s] Attempting to grow the bond dimensions."
        adaptbonddimensions!(state, PH, max_bond, convergence_factor_bonddims)

        stime = @elapsed begin
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.
                sweepdir = (ha == 1 ? "right" : "left")
                tdvp_site_update!(
                                  solver,
                    PH,
                    state,
                    site,
                    0.5Δt;
                    current_time=(ha == 1 ? current_time + 0.5Δt : current_time + Δt),
                    sweepdir=sweepdir,
                    hermitian=hermitian,
                    exp_tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                )
            end
        end
        current_time += Δt

        # Now the backwards sweep has ended, so the whole MPS of the state is up-to-date.
        # We can then calculate the expectation values of the observables within cb.
        for site in 1:N
            apply!(
                cb,
                state;
                t=current_time,
                bond=site,
                sweepend=true,
                sweepdir="right", # This value doesn't matter.
                alg=TDVP1(),
            )
        end

        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", current_time),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(state)),
            ],
        )

        if !isempty(measurement_ts(cb)) && current_time ≈ measurement_ts(cb)[end]
            if store_state0
                printoutput_data(
                    io_handle,
                    cb,
                    state;
                    psi0=state0,
                    vectorized=true,
                    sites=sites,
                    kwargs...,
                )
            else
                printoutput_data(
                    io_handle, cb, state; vectorized=true, sites=sites, kwargs...
                )
            end
            printoutput_ranks(ranks_handle, cb, state)
            printoutput_stime(times_handle, stime)
        end

        checkdone!(cb) && break
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end

"""
    adaptiveadjtdvp1vec!(
        solver,
        operator::MPS,
        initialstate::MPS,
        L::Vector{MPO},
        Δt::Number,
        tf::Number,
        meas_stride::Number,
        sites;
        kwargs...,
    )

Like `adjtdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`adjtdvp1vec!`](@ref).
"""
function adaptiveadjtdvp1vec!(
    solver,
    operator::MPS,
    initialstate::MPS,
    Ls::Vector{MPO},
    Δt::Number,
    tf::Number,
    meas_stride::Number,
    sites;
    kwargs...,
)
    for L in Ls
        ITensors.check_hascommoninds(siteinds, L, operator)
        ITensors.check_hascommoninds(siteinds, L, operator')
    end
    Ls .= ITensors.permute.(Ls, Ref((linkind, siteinds, linkind)))
    PLs = ProjMPOSum(Ls)
    return adaptiveadjtdvp1vec!(
        solver, operator, initialstate, PLs, Δt, tf, meas_stride, sites; kwargs...
    )
end

"""
    adaptiveadjtdvp1vec!(
        solver,
        operator::MPS,
        initialstate::MPS,
        L::MPO,
        Δt::Number,
        tf::Number,
        meas_stride::Number,
        sites;
        kwargs...,
    )

Like `adjtdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`adjtdvp1vec!`](@ref).
"""
function adaptiveadjtdvp1vec!(
    solver,
    operator::MPS,
    initialstate::MPS,
    L::MPO,
    Δt::Number,
    tf::Number,
    meas_stride::Number,
    sites;
    kwargs...,
)
    return adaptiveadjtdvp1vec!(
        solver, operator, initialstate, ProjMPO(L), Δt, tf, meas_stride, sites; kwargs...
    )
end

"""
    adaptiveadjtdvp1vec!(
        solver,
        operator::MPS,
        initialstate::MPS,
        PH,
        Δt::Number,
        tf::Number,
        meas_stride::Number,
        sites;
        kwargs...,
    )

Like `adjtdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.

See [`adjtdvp1vec!`](@ref).
"""
function adaptiveadjtdvp1vec!(
    solver,
    operator::MPS,
    initialstate::MPS,
    PH,
    Δt::Number,
    tf::Number,
    meas_stride::Number,
    sites;
    kwargs...,
)
    nsteps = Int(tf / Δt)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)
    convergence_factor_bonddims = get(kwargs, :convergence_factor_bonddims, 1e-4)
    max_bond = get(kwargs, :max_bond, maxlinkdim(operator))

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving operator... ")
    else
        pbar = nothing
    end

    # Vectorized equations of motion usually are not defined by an anti-Hermitian operator
    # such as -im H in Schrödinger's equation, so we do not bother here with "unitary" or
    # "imaginary-time" evolution types. We just have a generic equation of the form
    # v'(t) = L v(t).

    io_handle = open(io_file, "w")
    @printf(io_handle, "%20s", "time")
    @printf(io_handle, "%20s", "exp_val")
    @printf(io_handle, "\n")

    ranks_handle = writeheaders_ranks(ranks_file, length(operator))
    times_handle = writeheaders_stime(times_file)

    N = length(operator)

    current_time = zero(Δt)
    for s in 1:nsteps
        orthogonalize!(operator, 1)
        ITensors.set_nsite!(PH, 1)
        position!(PH, operator, 1)

        @debug "[Step $s] Attempting to grow the bond dimensions."
        adaptbonddimensions!(operator, PH, max_bond, convergence_factor_bonddims)

        stime = @elapsed begin
            # In TDVP1 only one site at a time is modified, so we iterate on the sites
            # of the operator MPS, not its bonds.
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.
                sweepdir = (ha == 1 ? "right" : "left")
                tdvp_site_update!(
                    solver,
                    PH,
                    operator,
                    site,
                    0.5Δt;
                    current_time=(ha == 1 ? current_time + 0.5Δt : current_time + Δt),
                    sweepdir=sweepdir,
                    hermitian=false,
                    exp_tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                )
            end
        end
        current_time += Δt

        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", current_time),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(operator)),
            ],
        )

        # Now the backwards sweep has ended, so the whole MPS of the operator is up-to-date.
        # We can then calculate the expectation values on the initial state.
        #if t - prev_t ≈ meas_stride... how does this work?
        if true
            @printf(io_handle, "%40.15f", current_time)
            @printf(io_handle, "%40.15f", real(inner(initialstate, operator)))
            @printf(io_handle, "\n")
            flush(io_handle)

            @printf(ranks_handle, "%40.15f", t)
            for bonddim in ITensors.linkdims(operator)
                @printf(ranks_handle, "%10d", bonddim)
            end
            @printf(ranks_handle, "\n")
            flush(ranks_handle)

            printoutput_stime(times_handle, stime)
        end
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end
