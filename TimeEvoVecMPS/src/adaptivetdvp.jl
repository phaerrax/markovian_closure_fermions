export adaptbonddimensions!, adaptivetdvp1!, adaptivetdvp1vec!, adaptiveadjtdvp1vec!

"""
    bondconvergencemeasure(PH::AbstractProjMPO, state::MPS, bond::Integer)

Return a measure of the convergence for the bond dimension on the bond (`bond`, `bond+1`)
of the MPS `state` for a time-evolution determined by `PH`. See [1] for details.

# References:
[1] Dunnett, Angus J. and Chin, Alex W. (2020).
“Dynamically Evolving Bond-Dimensions within the one-site
Time-Dependent-Variational-Principle method for Matrix Product States: Towards efficient
simulation of non-equilibrium open quantum dynamics”
https://doi.org/10.48550/arXiv.2007.13528
"""
function bondconvergencemeasure(PH::ITensors.AbstractProjMPO, v::MPS, bond::Integer)::Real
    #orthogonalize!(v, bond) # this causes trouble

    ITensors.set_nsite!(PH, 1)
    ITensors.position!(PH, v, bond)
    H1 = PH(v[bond])

    Q, R = factorize(
        v[bond], uniqueinds(v[bond], v[bond + 1]); ortho="left", which_decomp="qr"
    )
    vv = copy(v)
    vv[bond] = Q
    vv[bond + 1] *= R
    ITensors.setleftlim!(vv, bond)
    ITensors.setrightlim!(vv, bond + 1)

    ITensors.position!(PH, vv, bond + 1)
    H2 = PH(vv[bond + 1])

    ITensors.set_nsite!(PH, 0)
    ITensors.position!(PH, vv, bond + 1) # Force recalculation
    K = PH(R)

    return norm(H1)^2 + norm(H2)^2 + norm(K)^2
end

"""
    function adaptbonddimensions!(
        v::MPS, PH::AbstractProjMPO, max_bond::Int, convergence_factor_bonddims::Real
    )

If necessary, enlarge the bond dimensions of the MPS `v`, so that it can dynamically and
inhomogeneously restructure itself as the complexity of the correlations grow during the
time evolution generated by `H` [1].

# References:
[1] Dunnett, Angus J. and Chin, Alex W. (2020).
“Dynamically Evolving Bond-Dimensions within the one-site
Time-Dependent-Variational-Principle method for Matrix Product States: Towards efficient
simulation of non-equilibrium open quantum dynamics”
https://doi.org/10.48550/arXiv.2007.13528
"""
function adaptbonddimensions!(
    v::MPS, PH::ITensors.AbstractProjMPO, max_bond::Int, convergence_factor_bonddims::Real
)
    maxbonddimensions = maxlinkdims(v, max_bond)
    for bond in 1:(length(v) - 1)
        if linkdim(v, bond) < maxbonddimensions[bond]
            # Skip all this if the bond is already at (or above!) the maximum
            # allowed value.
            f = bondconvergencemeasure(PH, v, bond)
            while true # (do-while block emulation)
                # Increase the bond dimension by 1, check convergence, repeat if needed.
                vcopy = copy(v)
                new_bonddim = growbond!(vcopy, bond)
                # Update PH using the new sites at `bond` and `bond + 1`:
                recompute!(PH, vcopy, bond)
                new_f = bondconvergencemeasure(PH, vcopy, bond)

                # If new_f / f ≈ 1, within the given threshold, then f was already OK
                # and we discard the new MPS, keeping the non-enlarged state.
                if (new_f / f - 1 > convergence_factor_bonddims && new_bonddim ≤ max_bond)
                    d = growbond!(v, bond) # Actually increase v's bond dimensions
                    #d = linkdim(v, bond)
                    @debug "[Bond ($bond,$(bond+1))] f($d)/f($(d-1)) - 1 > " *
                        "$convergence_factor_bonddims: increasing dimension to $d."
                    f = new_f # and begin a new iteration of the while block.
                else
                    # Bring PH back to its form before v's bond dimension was increased.
                    recompute!(PH, v, bond)
                    @debug "[Bond ($bond,$(bond+1))] Convergence reached at d=$(linkdim(v, bond))."
                    break # and proceed with the next bond in the MPS.
                end
            end
        else
            @debug "[Bond ($bond,$(bond+1))] Max dimension reached. Skipping."
        end
    end
    return nothing
end


"""
    adaptivetdvp1!(state, H::MPO, Δt, tf, sites; kwargs...)

Like `tdvp1!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.
"""
function adaptivetdvp1!(state, H::MPO, timestep, tf; kwargs...)
    nsteps = Int(tf / timestep)
    cb = get(kwargs, :callback, NoTEvoCallback())
    hermitian = get(kwargs, :hermitian, true)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    normalize = get(kwargs, :normalize, true)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)
    store_state0 = get(kwargs, :store_psi0, false)
    convergence_factor_bonddims = get(kwargs, :convergence_factor_bonddims, 1e-4)
    max_bond = get(kwargs, :max_bond, maxlinkdim(state))

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving state... ")
    else
        pbar = nothing
    end

    Δt = im * timestep
    imag(Δt) == 0 && (Δt = real(Δt))

    store_state0 && (state0 = copy(state))

    io_handle = writeheaders_data(io_file, cb; kwargs...)
    ranks_handle = writeheaders_ranks(ranks_file, length(state))
    times_handle = writeheaders_stime(times_file)

    N = length(state)

    # Prepare for first iteration
    orthogonalize!(state, 1)
    PH = ProjMPO(H)
    singlesite!(PH)
    position!(PH, state, 1)

    for s in 1:nsteps
        PH = ProjMPO(H)
        orthogonalize!(state, 1)
        ITensors.set_nsite!(PH, 1)
        position!(PH, state, 1)

        # Before each sweep, we grow the bond dimensions a bit.
        # See Dunnett and Chin, 2020 [arXiv:2007.13528v2].
        @debug "[Step $s] Attempting to grow the bond dimensions."
        adaptbonddimensions!(state, PH, max_bond, convergence_factor_bonddims)

        stime = @elapsed begin
            # In TDVP1 only one site at a time is modified, so we iterate on the sites
            # of the state's MPS, not the bonds.
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.
                # 
                # Create a one-site projection of the Hamiltonian on the first site.
                ITensors.set_nsite!(PH, 1)
                ITensors.position!(PH, state, site)

                # TODO Here we could merge TDVP1 and TDVP2.
                # φ = state[site]

                # DEBUG
                #println("Forward time evolution: site, ha ",site, ha);

                #exptime = @elapsed begin
                φ, info = exponentiate(
                    PH,
                    -0.5Δt,
                    state[site];
                    ishermitian=hermitian,
                    tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                    eager=true,
                )
                #end
                #println("Forward exponentiation elapsed time: ", exptime)
                info.converged == 0 && throw("exponentiate did not converge")

                # Replace (temporarily) the local tensor with the evolved one.
                state[site] = φ

                # Calculate the expectation values of the observables within cb.
                # TODO Check if measurement is faulty.
                #mtime = @elapsed begin
                apply!(
                    cb,
                    state;
                    t=s * timestep,
                    bond=site,
                    sweepend=ha == 2,
                    sweepdir=ha == 1 ? "right" : "left",
                    #spec=spec,
                    alg=TDVP1(),
                )
                #end mtime
                #println("Tempo per misure: ", mtime)

                # Copypasted from
                #https://github.com/ITensor/ITensorTDVP.jl/blob/main/src/tdvp_step.jl
                if (ha == 1 && (site != N)) || (ha == 2 && site != 1)
                    # Start from a right-canonical MPS A, where each matrix A(n) = Aᵣ(n) is
                    # right-orthogonal.
                    # Start at site n = 1 and repeat the following steps:
                    # 1. Evolve A(n) for a time step Δt.
                    # 2. Factorize the updated A(n) as Aₗ(n)C(n) such that the matrix Aₗ,
                    # which will be left at site n, is left-orthogonal.
                    # 3. Evolve C(n) backwards in time according for a time step Δt, before
                    # absorbing it into the next site to create A(n + 1) = C(n)Aᵣ(n + 1).
                    # 4. Evolve A(n + 1) and so on...
                    #
                    b1 = (ha == 1 ? site + 1 : site) # ???
                    Δb = (ha == 1 ? +1 : -1)
                    # site + Δb is the physical index of the next site in the sweep.
                    uinds = uniqueinds(φ, state[site + Δb])

                    #svdtime = @elapsed begin
                    U, S, V = svd(φ, uinds)
                    #end
                    #println("Tempo svd: ", svdtime)

                    state[site] = U # This is left(right)-orthogonal if ha==1(2).
                    phi0 = S * V
                    if ha == 1
                        ITensors.setleftlim!(state, site)
                    elseif ha == 2
                        ITensors.setrightlim!(state, site)
                    end

                    ITensors.set_nsite!(PH, 0)
                    #postime = @elapsed begin
                    position!(PH, state, b1)
                    #end
                    #println("tempo position site+1", postime)

                    #Debug
                    #println("Backward-time site, ha", site, ha)
                    #exptime = @elapsed begin
                    phi0, info = exponentiate(
                        PH,
                        0.5Δt,
                        phi0;
                        ishermitian=hermitian,
                        tol=exp_tol,
                        krylovdim=krylovdim,
                        maxiter=maxiter,
                        eager=true,
                    )
                    #end
                    #println("Tempo esponenziazione indietro: ", exptime)
                    #println("backward done!")

                    # Reunite the backwards-evolved C(site) with the matrix on the
                    # next site.
                    state[site + Δb] = phi0 * state[site + Δb]

                    if ha == 1
                        ITensors.setrightlim!(state, site + Δb + 1)
                    elseif ha == 2
                        ITensors.setleftlim!(state, site + Δb - 1)
                    end

                    ITensors.set_nsite!(PH, 1)
                end

                # Adesso il passo di evoluzione e` finito.
                # Considerando che misuriamo "durante" lo sweep
                # a sx, adesso l'ortogonality center e` sul sito a sx del bond
                # quindi credo che la misura vada spostata piu` su
                # ovvero prima di rendere il tensore right orthogonal
            end
        end

        #println("time-step time: ",s*dt," t=", stime)
        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", timestep * s),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(state)),
            ],
        )

        if !isempty(measurement_ts(cb)) && timestep * s ≈ measurement_ts(cb)[end]
            if store_state0
                printoutput_data(io_handle, cb, state; psi0=state0, kwargs...)
            else
                printoutput_data(io_handle, cb, state; kwargs...)
            end
            printoutput_ranks(ranks_handle, cb, state)
            printoutput_stime(times_handle, stime)
        end

        checkdone!(cb) && break
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end

"""
    adaptivetdvp1vec!(state, H::MPO, Δt, tf, sites; kwargs...)

Like `tdvp1vec!`, but grows the bond dimensions of the MPS along the time evolution until
a certain convergence criterium is met.
"""
function adaptivetdvp1vec!(state, H::MPO, Δt, tf, sites; kwargs...)
    nsteps = Int(tf / Δt)
    cb = get(kwargs, :callback, NoTEvoCallback())
    hermitian = get(kwargs, :hermitian, true)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    normalize = get(kwargs, :normalize, false)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)
    store_state0 = get(kwargs, :store_psi0, false)
    convergence_factor_bonddims = get(kwargs, :convergence_factor_bonddims, 1e-4)
    max_bond = get(kwargs, :max_bond, maxlinkdim(state))

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving state... ")
    else
        pbar = nothing
    end

    # Vectorized equations of motion usually are not defined by an anti-Hermitian operator
    # such as -im H in Schrödinger's equation, so we do not bother here with "unitary" or
    # "imaginary-time" evolution types. We just have a generic equation of the form
    # v'(t) = L v(t).

    store_state0 && (state0 = copy(state))

    io_handle = writeheaders_data(io_file, cb; kwargs...)
    ranks_handle = writeheaders_ranks(ranks_file, length(state))
    times_handle = writeheaders_stime(times_file)

    N = length(state)

    for s in 1:nsteps
        PH = ProjMPO(H)
        orthogonalize!(state, 1)
        ITensors.set_nsite!(PH, 1)
        position!(PH, state, 1)

        # Before each sweep, we grow the bond dimensions a bit.
        # See Dunnett and Chin, 2020 [arXiv:2007.13528v2].
        @debug "[Step $s] Attempting to grow the bond dimensions."
        adaptbonddimensions!(state, PH, max_bond, convergence_factor_bonddims)

        stime = @elapsed begin
            # In TDVP1 only one site at a time is modified, so we iterate on the sites
            # of the state's MPS, not the bonds.
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.

                # The algorithm starts from a right-canonical MPS A, where each matrix
                # A(n) = Aᵣ(n) is right-orthogonal.

                # 1. Project the Hamiltonian on the current site.
                #    --------------------------------------------

                ITensors.set_nsite!(PH, 1)
                ITensors.position!(PH, state, site)

                # 3. Evolve C(n) backwards in time according for a time step Δt, before
                # absorbing it into the next site to create A(n + 1) = C(n)Aᵣ(n + 1).
                # 4. Evolve A(n + 1) and so on...

                # 2. Evolve A(site) for half the time-step Δt.
                #    -----------------------------------------

                φ, info = exponentiate(
                    PH,
                    0.5Δt,
                    state[site];
                    ishermitian=hermitian,
                    tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                    eager=true,
                )
                info.converged == 0 && throw("exponentiate did not converge")

                # Now we take different steps depending on whether we are at
                # the end of the half-sweep or not.
                if (ha == 1 && site != N) || (ha == 2 && site != 1)
                    # 3. Factorize the updated A(site) as Aₗ(site)C(site) such that the
                    #    matrix Aₗ is left-orthogonal.
                    #    --------------------------------------------------------------

                    Δs = (ha == 1 ? 1 : -1)
                    # site + Δs is the physical index of the next site in the sweep.

                    # Perform the SVD decomposition. Note that the group of indices
                    # provided by the second argument is interpreted as the "left index"
                    # of φ, therefore there is no need to "reverse" the indices when we
                    # are performing the right-to-left sweep: everything is taken care of
                    # by ITensors accordingly.
                    U, S, V = svd(φ, uniqueinds(φ, state[site + Δs]))

                    state[site] = U # This is left(right)-orthogonal if ha==1(2).
                    C = S * V
                    if ha == 1
                        ITensors.setleftlim!(state, site)
                        # This has something to do with the range within the MPS where the
                        # orthogonality properties hold...
                    elseif ha == 2
                        ITensors.setrightlim!(state, site)
                    end

                    # 4. Evolve C(site) backwards in time of a half-step Δt/2 and
                    #    incorporate in the matrix Aᵣ(site+1) of the next site along
                    #    the sweep.
                    #    -----------------------------------------------------------

                    # Calculate the new zero-site projection of the evolution operator.
                    ITensors.set_nsite!(PH, 0)
                    position!(PH, state, ha == 1 ? site + 1 : site)
                    # Shouldn't we have ha == 1 ? site+1 : site-1 ?

                    C, info = exponentiate(
                        PH,
                        -0.5Δt,
                        C;
                        ishermitian=hermitian,
                        tol=exp_tol,
                        krylovdim=krylovdim,
                        maxiter=maxiter,
                        eager=true,
                    )

                    # Incorporate the backwards-evolved C(site) with the matrix on the
                    # next site.
                    state[site + Δs] = C * state[site + Δs]

                    if ha == 1
                        ITensors.setrightlim!(state, site + Δs + 1)
                    elseif ha == 2
                        ITensors.setleftlim!(state, site + Δs - 1)
                    end

                    # Reset the single-site projection of the evolution operator,
                    # ready for the next sweep.
                    ITensors.set_nsite!(PH, 1)
                else
                    # There's nothing to do if the half-sweep is at the last site.
                    state[site] = φ
                end
            end
        end

        # Now the backwards sweep has ended, so the whole MPS of the state is up-to-date.
        # We can then calculate the expectation values of the observables within cb.
        for site in 1:N
            apply!(
                cb,
                state;
                t=Δt * s,
                bond=site,
                sweepend=true,
                sweepdir="right", # The value doesn't matter.
                alg=TDVP1(),
            )
        end

        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", Δt * s),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(state)),
            ],
        )

        if !isempty(measurement_ts(cb)) && Δt * s ≈ measurement_ts(cb)[end]
            if store_state0
                printoutput_data(
                    io_handle,
                    cb,
                    state;
                    psi0=state0,
                    vectorized=true,
                    sites=sites,
                    kwargs...,
                )
            else
                printoutput_data(
                    io_handle, cb, state; vectorized=true, sites=sites, kwargs...
                )
            end
            printoutput_ranks(ranks_handle, cb, state)
            printoutput_stime(times_handle, stime)
        end

        checkdone!(cb) && break
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end

"""
    adaptiveadjtdvp1vec!(operator::MPS, initialstate::MPS, H::MPO, Δt, tf, meas_stride, sites; kwargs...)

Compute the time evolution, generated by the GKSL superoperator encoded in `H`, of the
operator `operator` in the Heisenberg picture, periodically measuring its expectation
value on the state `initialstate`.

# Arguments
- `operator::MPS`: an MPS representing the initial value of the operator.
- `initialstate::MPS` an MPS representing the initial state of the system.
- `H::MPO`: the MPO representing the GKSL "superoperator".
- `Δt`: the time step for the evolution.
- `tf`: the end time of the simulation.
- `meas_stride`: time between each measurement.
- `sites`: an array of ITensor sites on which the MPSs and MPOs above are defined.

# Keyword arguments
- `io_file`: output file of the measurements.
- `ranks_file`: output file for the bond dimensions of the operator's MPS.
- `times_file`: output file for the simulation time.

# Other keyword options, passed to `KrylovKit.exponentiate`
- `exp_tol::Real` -> `tol`
- `krylovdim::Int`
- `maxiter::Int`
"""
function adaptiveadjtdvp1vec!(
    operator::MPS, initialstate::MPS, H::MPO, Δt, tf, meas_stride, sites; kwargs...
)
    nsteps = Int(tf / Δt)
    exp_tol = get(kwargs, :exp_tol, 1e-14)
    krylovdim = get(kwargs, :krylovdim, 30)
    maxiter = get(kwargs, :maxiter, 100)
    io_file = get(kwargs, :io_file, nothing)
    ranks_file = get(kwargs, :io_ranks, nothing)
    times_file = get(kwargs, :io_times, nothing)
    convergence_factor_bonddims = get(kwargs, :convergence_factor_bonddims, 1e-4)
    max_bond = get(kwargs, :max_bond, maxlinkdim(operator))

    if get(kwargs, :progress, true)
        pbar = Progress(nsteps; desc="Evolving operator... ")
    else
        pbar = nothing
    end

    # Vectorized equations of motion usually are not defined by an anti-Hermitian operator
    # such as -im H in Schrödinger's equation, so we do not bother here with "unitary" or
    # "imaginary-time" evolution types. We just have a generic equation of the form
    # v'(t) = L v(t).

    io_handle = open(io_file, "w")
    @printf(io_handle, "%20s", "time")
    @printf(io_handle, "%20s", "exp_val")
    @printf(io_handle, "\n")

    ranks_handle = writeheaders_ranks(ranks_file, length(operator))
    times_handle = writeheaders_stime(times_file)

    N = length(operator)

    prev_t = zero(Δt)
    for s in 1:nsteps
        PH = ProjMPO(H)
        orthogonalize!(operator, 1)
        ITensors.set_nsite!(PH, 1)
        position!(PH, operator, 1)

        @debug "[Step $s] Attempting to grow the bond dimensions."
        adaptbonddimensions!(operator, PH, max_bond, convergence_factor_bonddims)

        stime = @elapsed begin
            # In TDVP1 only one site at a time is modified, so we iterate on the sites
            # of the operator MPS, not its bonds.
            for (site, ha) in sweepnext(N; ncenter=1)
                # sweepnext(N) is an iterable object that evaluates to tuples of the form
                # (bond, ha) where bond is the bond number and ha is the half-sweep number.
                # The kwarg ncenter determines the end and turning points of the loop: if
                # it equals 1, then we perform a sweep on each single site.

                # The algorithm starts from a right-canonical MPS A, where each matrix
                # A(n) = Aᵣ(n) is right-orthogonal.

                # 1. Project the Hamiltonian on the current site.
                #    --------------------------------------------

                ITensors.set_nsite!(PH, 1)
                ITensors.position!(PH, operator, site)

                # 2. Evolve A(site) for half the time-step Δt.
                #    -----------------------------------------

                φ, info = exponentiate(
                    PH,
                    0.5Δt,
                    operator[site];
                    ishermitian=false,
                    tol=exp_tol,
                    krylovdim=krylovdim,
                    maxiter=maxiter,
                    eager=true,
                )
                info.converged == 0 && throw("exponentiate did not converge")

                # Now we take different steps depending on whether we are at
                # the end of the half-sweep or not.
                if (ha == 1 && site != N) || (ha == 2 && site != 1)
                    # 3. Factorize the updated A(site) as Aₗ(site)C(site) such that the
                    #    matrix Aₗ is left-orthogonal.
                    #    --------------------------------------------------------------

                    Δs = (ha == 1 ? 1 : -1)
                    # site + Δs is the physical index of the next site in the sweep.

                    # Perform the SVD decomposition. Note that the group of indices
                    # provided by the second argument is interpreted as the "left index"
                    # of φ, therefore there is no need to "reverse" the indices when we
                    # are performing the right-to-left sweep: everything is taken care of
                    # by ITensors accordingly.
                    U, S, V = svd(φ, uniqueinds(φ, operator[site + Δs]))

                    operator[site] = U # This is left(right)-orthogonal if ha==1(2).
                    C = S * V
                    if ha == 1
                        ITensors.setleftlim!(operator, site)
                        # This has something to do with the range within the MPS where the
                        # orthogonality properties hold...
                    elseif ha == 2
                        ITensors.setrightlim!(operator, site)
                    end

                    # 4. Evolve C(site) backwards in time of a half-step Δt/2 and
                    #    incorporate in the matrix Aᵣ(site+1) of the next site along
                    #    the sweep.
                    #    -----------------------------------------------------------

                    # Calculate the new zero-site projection of the evolution operator.
                    ITensors.set_nsite!(PH, 0)
                    position!(PH, operator, ha == 1 ? site + 1 : site)
                    # Shouldn't we have ha == 1 ? site+1 : site-1 ?

                    C, info = exponentiate(
                        PH,
                        -0.5Δt,
                        C;
                        ishermitian=false,
                        tol=exp_tol,
                        krylovdim=krylovdim,
                        maxiter=maxiter,
                        eager=true,
                    )

                    # Incorporate the backwards-evolved C(site) with the matrix on the
                    # next site.
                    operator[site + Δs] = C * operator[site + Δs]

                    if ha == 1
                        ITensors.setrightlim!(operator, site + Δs + 1)
                    elseif ha == 2
                        ITensors.setleftlim!(operator, site + Δs - 1)
                    end

                    # Reset the single-site projection of the evolution operator,
                    # ready for the next sweep.
                    ITensors.set_nsite!(PH, 1)
                else
                    # There's nothing to do if the half-sweep is at the last site.
                    operator[site] = φ
                end
            end
        end
        prev_t += Δt
        t = Δt * s

        !isnothing(pbar) && ProgressMeter.next!(
            pbar;
            showvalues=[
                ("t", t),
                ("Δt step time", round(stime; digits=3)),
                ("Max bond-dim", maxlinkdim(operator)),
            ],
        )

        # Now the backwards sweep has ended, so the whole MPS of the operator is up-to-date.
        # We can then calculate the expectation values on the initial state.
        #if t - prev_t ≈ meas_stride... how does this work?
        if true
            @printf(io_handle, "%40.15f", t)
            @printf(io_handle, "%40.15f", real(inner(initialstate, operator)))
            @printf(io_handle, "\n")
            flush(io_handle)

            @printf(ranks_handle, "%40.15f", t)
            for bonddim in ITensors.linkdims(operator)
                @printf(ranks_handle, "%10d", bonddim)
            end
            @printf(ranks_handle, "\n")
            flush(ranks_handle)

            printoutput_stime(times_handle, stime)
        end
    end

    !isnothing(io_file) && close(io_handle)
    !isnothing(ranks_file) && close(ranks_handle)
    !isnothing(times_file) && close(times_handle)

    return nothing
end
